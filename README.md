# Python Type Static Analysis Tool
## Description
This project is designed to analyze variables’ types in relatively simple python programs using value agnostic static analysis. Analysis results are presented in three formats—type analysis highlighting, type history flowcharts, and error report summary. The analysis results aim to provide entry level/beginner python programmers with necessary information regarding undeclared/unspecified types in unfamiliar code and provide guidance for programs they are writing.

## Installation
### Libraries
#### Static analysis (ast_parser/parser.py)
- ast 
- os 
- numpy
- json 
- visual     
#### Visualization (ast_parser/visual.py)
- os 
- numpy
- yattag
- matplotlib.pylot 
- re    
- graphviz (needs to be installed to system path, follow instructions here https://graphviz.org/download/)
- glob
## Instructions
### Execution

    python parser.py

### User Input
The default input file is input1.py, the contents of this file will be analyzed by the static analysis program. Users can replace the contents of this file with the code they want to analyze. Alternatively, users could also replace the file name in “file = os.path.join('..', 'input_files', 'input1.py')” found in the main function in ast_parser/parser.py in line 63. Input programs must only contain function definitions, for a more in depth definition of the scope supported by this project, refer to the feature descriptions in the static analysis section.
### Visualization Output
All analysis and visualization results are grouped together under the webpage output/main.html. The page contains links to the type analysis highlighting, type history flowcharts, and error report summary. If the user desires to access the individual flowcharts generated by the program, both .svg and .gv(dot) formats for each function can be found under output/flowchart/*.
### Sample Programs
Sample functions could be found in input_files/sample.py. This file contains sample functions sufficiently complex for demonstrating the capabilities of this static analysis program.
### Simple Examples
Simple examples along with their expected output can be found under input_files/test.py. These examples are meant to be referenced when reading the detailed feature descriptions under the static analysis section.
### External Libraries
The file input_files/functions_return.json contains functions supported by the analysis program. Refer to the supported libraries section under static analysis for more details.

## Static Analysis
### Control Flow
We have implemented the static analysis of conditional statements such as if/for/while and their nested variants. </br></br>
if and if-else-elif: We overestimate the possible data types by taking the union of all conditional branches, including nested ones. In addition, since our analysis is value-agnostic and independent of the logical branching, we decided that if a variable is modified inside of an if block, the variable’s most current set of types before the current if block would also be included in the possible set of types (this is another overestimation). For examples, refer to the functions in input_files/test.py lines 1-119. In addition, if conditions are ignored in our analysis.</br>
</br>For loops: We process the for loop iterator as an initialization assignment in certain scenarios. In the example in input_files/test.py line 123, where we have “for i in [1, ‘str’]”. If the iterable structure is explicitly declared in the loop iterator, we overestimate by assigning the union of all types in the given list to the possible types of the variable. Iterable structures that we support in for loops include non-nested list, non-nested set, non-nested tuple, and strings. In the examples at line 140 and 147 in input_files/test.py, since our analysis program is mostly value-agnostic, the information of types in the given list is lost once they are passed by either variable reference or function return. Therefore, in cases such as above, if the iterable value referenced is of type list, tuple, set, or multiple types, then the variable’s type would be ambiguous. However, if the iterable value referenced is of type string, then the variable's type would remain string. Note that we only support one variable in the for loop condition, i.e. “for i,k” is not supported. Moreover, the iteration logic is ignored in our analysis.
</br></br>While-else and try-except-finally statements are not supported.
### Operations
We can perform type check on unary operations (not, ~, +, -), boolean operations (and, or), and binary operations (+, -, *, /, **, %). In particular, we only let legal operations to be performed depending on the types of the variables used as operands. Illegal operations will result in an ‘Error’ assignment, whereas ambiguous types will result in an ‘Ambiguous’ assignment. Ilegal unary operations will result in an appearance of “not an unary operator type” in the error log. Ilegal binary operations will result in an appearance of “error, invalid binaryop type” in the error log. In addition, operations support operands such as function calls, variables, etc. Boolean and binary operations could also be nested, i.e. (1 + 2 + (3 + 4)). Examples of these operations could be found in input_files/test.py lines 154-190.
### Function Declaration & Argument Type Inference
Arguments or variables of a function are instantiated with the function definition. We overestimate by starting these variables with all possible types. As each line of the body of the function is processed, we infer from operations involving the corresponding argument and prune the set of possible types to only retain types that will result in valid operations. This implementation aims to prioritize as many sequential lines as possible to execute without encountering errors. These operations include binary operation, unary operation, boolean operation (note all supported types are legal for boolean operation, so this has no effects), and function calls. Note, in our analysis program, no function argument should undergo assignment. The analysis assumes that arguments are read-only variables. In addition, as the argument’s set of possible types is pruned, no variable that is dependent on the corresponding argument would be updated. As dependencies might end up with a larger set of possibilities than the argument, this is another case of overestimation. An example can be found in input_files/test.py lines 232-241.
### Function Returns
Return types are based on the most recent assignment or type update for each corresponding variable.
### Function Call Parameter Type Checks & Argument Type Inference Cont.
When calling a function, the parameters passed in will be type checked against the type inference done during function declaration. This analysis program assumes that all functions must be declared before being called. If every parameter passed in is a subset of the corresponding argument’s inferred types, then the function call is considered legal. If a parameter’s possible types only intersect with the corresponding argument’s inferred types, then the function call is considered ‘Ambiguous’. If a parameter’s possible types do not intersect with the corresponding argument’s inferred types, then the function call is considered ‘Error’. If the parameter being passed in is an argument of the current function, the analysis program will attempt to intersect the argument’s possible types with the legal types of the corresponding parameter. If the intersection is non-empty, then the argument’s set of types will be pruned to the intersection, otherwise ‘‘Ambiguous’ and ‘Error’ will be assigned accordingly.
### Internal Function Call
Internal function calls are supported. This analysis program does not support class declarations in the to-be-analyzed input file. All code being analyzed must be declared under functions. Internal function calls cannot use the same name as static functions, such as print, per standard python practices. An example can be found in input_files/test.py lines 213-216.
### External Function Call
Calls to external libraries are supported if declared in the JSON mapping, read ‘Supported Libraries’ for more information. In addition, external calls can be chained, i.e. x = f1().f2().f3(). Supported libraries are mapped according to their class. Built in functions are mapped under the ‘static’ class. All supported functions must have their return types mapped in the JSON mapping. For examples refer to functions declared in functions_return.json Examples can be found in input_files/test.py lines 219-229.
### Object Function Call & Argument Type Inference Cont.
Object calls for built-in types are supported. For example, “aaa”.split() is legal if the split function is mapped under class ‘str’ in the JSON mapping. If the object being called is an argument of the current function, then the analysis program will attempt to perform the object call with each possible type in said argument’s set of possible types. All types with successful calls will be unioned together. If no types are successful, then the argument’s set of types is not changed. Otherwise, the argument’s set of types becomes the unioned set of successful types/calls.
### Function Call Chaining & Nesting
Chaining external calls is legal. External calls can be used with object calls. Local calls can be chained with object calls. Function calls can be nested within each other as parameters. However, function parameters are not checked except for the to-be-analyzed input functions.  An example can be found in input_files/test.py lines 248-258.
### Function Overloading
Function definition overloading is supported. For example, a # parameter function is mapped as fn_name|#. An example can be found in input_files/test.py lines 261-277.
### Types Checked
The types supported by this analysis program are int, float, bool, str, list, tuple, set, and dictionary.
### Abstract State
The state for our static analysis is stored in a nested map with the following format {function name: {var name: {line number: possible type}}}.
### Supported Libraries
We implemented a functionality that loads a map from a JSON file with the format {class name: {function name: {return: {line number: possible type}}}}. This means that the possible external classes and their functions’ return types need to be included in this file before running the static analysis. Following the same format, users can expand the list of supported functions by modifying this JSON file. 
</br>By default, we have included the following functions:</br>
- numpy.random.randint(a)
- numpy.random.randrange(a)
- numpy.random.random()
- str.split(a)
- str.index(a)
- str.replace(a, b)
- str.find(a)
- list.copy()
- list.index(a)
- list.append(a)
- list.clear()
- list.count(a)
- list.insert(a, b)
- list.remove()
- list.pop() 
- static.abs(a)
- static.all(a)
- static.any(a)
- static.dict(a)
- static.int(a)
- static.isinstance(a,b)
- static.bool(a)
- static.len(a)
- static.list(a)
- static.max(a,b)
- static.min(a,b)
- static.range(a)
- static.str(a)
- static.tuple(a)
- static.print(a)
</br> Note: Static functions are written without "static." in input programs. For example, "static.print(a)" is written as "print(a)". Other functions must be written as is, as this program does not support name aliasing.

